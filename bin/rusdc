#!/usr/bin/env ruby

require "thor"
require 'tempfile'
require "erb"
require "usd"

class Rusdc < Thor

  desc "chg_add_nr <co> <ci>", "add a CI to a changeorder"
  def chg_add_nr(co, ci)
    template = ERB.new <<-EOF
      {
        "lrel_asset_chgnr": {
          "chg": {
            "@id": "<%= uid_co %>"
          },
          "nr": {
            "@id": "<%= uid_nr %>"
          }
        }
      }
    EOF
    json = template.result_with_hash(:uid_co => loadcon.request("/caisd-rest/chg/COMMON_NAME-#{co}")["chg"]["@id"], :uid_nr => loadcon.request("/caisd-rest/nr/COMMON_NAME-#{ci}")["nr"]["@id"])
    puts loadcon.create({:type => "json", :data => json})
  end

  desc "chg_list_nr <co>", "list all CIs of one changeorder"
  def chg_list_nr(co)
    invoke 'find', ['lrel_asset_chgnr', %(chg.chg_ref_num = '#{co}'), "nr"], {:format => "mlr"}
  end

  desc "create", "pipe json-data to create object"
  def create()
    puts loadcon.create({:type => "json", :data => STDIN.read})
  end

  desc "field_names <object-type> [wc]","list all fields of an object including its format"
  def field_names(object,wc="")
    e = loadcon.search(object,{'fields' => "*","wc"=>wc,"start" => "1", "size" => "1"})[0]
    e.keys.sort.each do |k|
      if e[k].class  == Hash
        puts "#{k} (#{e[k].class}):"
        puts e[k].jp
      else
        puts "#{k} (#{e[k].class}) : #{e[k]}"
      end
    end
  end

  desc "find <object-type> [where-clause] [fields, comma separated] [options]", "finds each object which meets the wc-condition"
  long_desc <<-LONGDESC


    with --mlr_format you may change the output-format of Miller (mlr) to csv, md (markdown), xtab , dkvp (delimited key-value pairs) ..., refer `mlr --help`

    Examples:

    - all grc objects (! don't use this kind of query for objecttype like nr, in, chg etc., whose number of objects is too big)
    rusdc find grc

    - all aktive ci which start with the string `servername`, only print the fields @id and name:
    rusdc find nr "name like 'servername%' and delete_flag.sym = 'Active' " "@id,name" --format mlr

    - my active incidents with most importent fields:
    rusdc find --format mlr in "assignee.last_name = 'gaida' and status.sym in ('Service pending','Work in progress.','Customer Pending','Open','Hold','Resolved')" ref_num,z_project,summary,status,call_back_date,affected_resource,orig_user_organization

    - activity-Log of an incident in xtab format:
    rusdc find alg "call_req_id.ref_num = 'I00001'" "call_req_id,action_desc,analyst,description,time_stamp,type" --format mlr --mlr_format xtab

    - the same but only the field description in csv-format:
    rusdc find alg "call_req_id.ref_num = 'I00001'" "description" --format mlr --mlr_format csv

    - incidents of the ci with the name `servername`
    rusdc find in "affected_resource.name = 'servername'" "ref_num,summary" --format mlr

    - combination of all activity-log-description of all incidents of a specific ci in pprint-Miller-format:
    rusdc find alg "call_req_id.affected_resource.name = 'servername'" "description" --format mlr

    - changeorders of a secific ci:
    rusdc find chg "asset.nr.name = 'servername'" "@COMMON_NAME,summary,status" --format mlr

    - find all active ci whose name start with dc and check if they have children like Windows or Linux server:
    for ci in $(rusdc find nr "name like 'dc%' and delete_flag.sym = 'active'" "name" --format mlr | sed '1 d'); do rusdc nr_childs $ci > help ; echo "$ci: $(grep -iP '^(Linux|.*MS windows).*server' help)" ; done

  LONGDESC
  option :format, :type => :string, :default => "json", :banner => "[json|yaml|mlr]"
  option :mlr_format, :type => :string, :default => "pprint",:banner => "[pprint|json|md|csv|xtab]"
  option :nice_time, :type => :boolean, :default => true,:banner => "[true|false]"
  option :debug, :type => :boolean, :default => false,:banner => "[true|false]"
  def find(object, wc="", fields="@COMMON_NAME")
    exitcode=0
    unless (fields =~ /^[\w\_,@]+$/)
      puts "fields-problem: there must be only letters, numbers, comma, the @-sign or underscore, nothing else!"
    else
      con = loadcon
      mlr_array = []
      con.debug = options[:debug]
      e = con.search(object,{'fields' => fields,"wc" => wc})
      exitcode=1  if e.count == 0
      fields_array=fields.split(/,/)
      e.each do |elem|
        # init all requested keys with empty strings, better for mlr format and needed for fields-order
        fields_array.each do |elem_key|
            elem[elem_key]="" unless elem.has_key?(elem_key)
        end
        elem.keys.each do |elem_key|
          if options[:nice_time]
            if elem_key =~ /(date|last_mod|warranty_start|warranty_end|time_stamp)$/
              elem[elem_key]=Time.at(elem[elem_key]).to_s
            end
          end
          if fields_array.include?(elem_key)
            if elem[elem_key].class == Hash
              elem_value = elem[elem_key]["@COMMON_NAME"]
              elem.delete(elem_key)
              elem[elem_key] = elem_value
            end
          else
            elem.delete(elem_key)
          end
        end
        # sort the keys
        mlr_array << Hash[fields_array.map {|k| [k, elem[k]]}].jp
      end
      mlr = "[" + mlr_array.join(",") + "]"
      case options[:format]
      when "json"
        puts mlr
        exit exitcode
      when "yaml"
        # keys not sorted, maybe a todo
        puts e.to_yaml
        exit exitcode
      when "mlr"
        # hierfuer muss mlr verfuegbar sein
        file = Tempfile.new('json')
        cmd = %(mlr --ijson --o#{options[:mlr_format]} cat #{file.path})
        file.write(mlr)
        file.close
        puts `#{cmd}`
        file.unlink
        exit exitcode
      else
        puts "das Format #{options[:format]} ist nicht hinterlegt. Es gibt nur json, yaml oder mlr."
        exit 2
      end
    end # fields check
  end

  desc "get <object-type> <common_name|id>", "shows one object by name or id"
  option :by_id, :type => :boolean, :default => false
  option :yaml, :type => :boolean, :default => false
  def get(object, ident)
    if options[:by_id] || ident =~ /^U'[0-9A-F]/i
      e = loadcon.request("/caisd-rest/#{object}/#{ident}")
    else
      e = loadcon.request("/caisd-rest/#{object}/COMMON_NAME-#{ident}")
    end
    if e.class == Hash
      puts options[:yaml] ?  e[object].to_yaml : e[object].jp
    elsif e.message == "409 Conflict"
      puts %(#{e.message} - try with 'rusdc find #{object} "" "@COMMON_NAME" --format mlr | sort | uniq -c | sort -n -r | head -20', may be more then one object with this COMMON_NAME)
    else
      puts e.response
    end
  end

  desc "get_all_attachments_of_co <co_name>", "get all attachments of a changeorder and save all these to current folder"
  def get_all_attachments_of_co(coname)
    # todo : care more about eml-multipart: https://github.com/mikel/mail
    chg_id=loadcon.request("/caisd-rest/chg/COMMON_NAME-#{coname}")["chg"]["@id"]
    att_nr = loadcon.search("lrel_attachments_changes",{'fields' => "attmnt","wc" => "chg = #{chg_id}"})
    att_nr.each do |att|
      attmnt = loadcon.request("/caisd-rest/attmnt/#{att["attmnt"]["@id"]}")["attmnt"]
      filename = attmnt["orig_file_name"]
      puts "save #{filename}"
      f = File.open(filename, 'w')
      f.write(loadcon.request("/caisd-rest/attmnt/#{attmnt["@id"]}/file-resource",{:unchanged => true}))
      f.close
    end
    puts "all attachments were saved"
  end

  desc "get_attachment_of_ci <ci_name> <filename>", "download an attachment of a CI and print it out on stdout"
  def get_attachment_of_ci(ciname, filename)
    att_nr = loadcon.search("lrel_attachments_nr",{'fields' => "attmnt","wc" => "nr.name = '#{ciname}'"})
    att_nr.each do |att|
      attmnt = loadcon.request("/caisd-rest/attmnt/COMMON_NAME-#{att["attmnt"]["@id"]}")["attmnt"]
      if attmnt["orig_file_name"] == filename
        puts loadcon.request("/caisd-rest/attmnt/#{attmnt["@id"]}/file-resource",{:unchanged => true})
      end
    end
  end

  desc "get_attachment_of_co <co_name> <filename>", "download an attachment of a changeorder and print it out on stdout"
  def get_attachment_of_co(coname, filename)
    chg_id=loadcon.request("/caisd-rest/chg/COMMON_NAME-#{coname}")["chg"]["@id"]
    att_nr = loadcon.search("lrel_attachments_changes",{'fields' => "attmnt","wc" => "chg = #{chg_id}"})
    att_nr.each do |att|
      attmnt = loadcon.request("/caisd-rest/attmnt/COMMON_NAME-#{att["attmnt"]["@id"]}")["attmnt"]
      if attmnt["orig_file_name"] == filename
        puts loadcon.request("/caisd-rest/attmnt/#{attmnt["@id"]}/file-resource",{:unchanged => true})
      end
    end
  end

  desc "in_add_2_chg <changeorder> <incident>", "add incident to changeorder"
  def in_add_2_chg(chg, incident)
    invoke('update_ref_attr',['in', incident, 'change', chg])
  end

  desc "in_list_child_ins <in>", "list all child-incidents of one incident"
  def in_list_child_ins(incident)
    invoke('find',['cr', "parent.ref_num = '#{incident}'", "ref_num"], {:format => "mlr"})
  end

  desc "list_attachments_of_ci <ci_name>", "list all attachments of a CI"
  def list_attachments_of_ci(ciname)
    att_nr = loadcon.search("lrel_attachments_nr",{'fields' => "attmnt","wc" => "nr.name = '#{ciname}'"})
    att_nr.each do |att|
      puts loadcon.request("/caisd-rest/attmnt/COMMON_NAME-#{att["attmnt"]["@id"]}")["attmnt"]["orig_file_name"]
    end
  end

  desc "list_attachments_of_co <co_name>", "list all attachments of a changeorder"
  def list_attachments_of_co(coname)
    chg_id=loadcon.request("/caisd-rest/chg/COMMON_NAME-#{coname}")["chg"]["@id"]
    att_nr = loadcon.search("lrel_attachments_changes",{'fields' => "attmnt","wc" => "chg = #{chg_id}"})
    att_nr.each do |att|
      puts loadcon.request("/caisd-rest/attmnt/COMMON_NAME-#{att["attmnt"]["@id"]}")["attmnt"]["orig_file_name"]
    end
  end

  desc "nr_add_child <nr-name> <child-name>", "add one child CI to another CI"
  def nr_add_child(nr, child)
    template = ERB.new <<-EOF
      {
        "hier": {
          "child": {
             "@id": "<%= uid_child %>"
          },
          "parent": {
            "@id": "<%= uid_parent %>"
          }
        }
      }
    EOF
    json = template.result_with_hash(:uid_child => loadcon.request("/caisd-rest/nr/COMMON_NAME-#{child}")["nr"]["@id"], :uid_parent => loadcon.request("/caisd-rest/nr/COMMON_NAME-#{nr}")["nr"]["@id"])
    puts loadcon.create({:type => "json", :data => json})
  end

  desc "nr_changes <nr> [inactive-too]", "list all open changeorders of one CI"
  option :inactive_too, :type => :boolean, :default => false
  def nr_changes(nr)
    wc_add = (options[:inactive_too] ? "" : " and status.sym in ('Service pending','Work in progress','Customer Pending','Open','Hold')")
    wc =  %(asset.nr.name = '#{nr}'#{wc_add})
    invoke 'find', ['chg', wc, 'chg_ref_num,summary,status'], {:format => "mlr"}
  end

  desc "nr_childs <ci-name>", "lists all childs CIs of a specific CI"
  def nr_childs(name)
    loadcon.search("hier",{'fields' => "*","wc" => "parent.name = '#{name}'"}).each do |c|
      puts c["child"]["@COMMON_NAME"]
    end
  end

  desc "nr_incidents <nr> [inactive-too]", "lists all incident of a specific CI"
  option :inactive_too, :type => :boolean, :default => false
  def nr_incidents(nr)
    invoke 'find', ['in', %(affected_resource.name = '#{nr}'#{options[:inactive_too] ? "" : " and not status.sym in ('Cancelled','Closed')"}), "ref_num,summary,status"], {:format => "mlr"}
  end

  desc "nr_parents <ci-name>", "lists all parent CIs of a specific CI"
  def nr_parents(name)
    loadcon.search("hier",{'fields' => "*","wc" => "child.name = '#{name}'"}).each do |c|
      puts c["parent"]["@COMMON_NAME"]
    end
  end

  desc "update", "pipe json-data to update object"
  long_desc <<-LONGDESC

  Hier ein Beispiel

  ciname=servername
  rusdc find nr "name like '$ciname'" "z_backup" |jq '{nr:(.[0]|.z_backup= (.z_backup +"\n----\neine neue Zeile")|del(.link,."@id",."@REL_ATTR"))}' | rusdc update

  LONGDESC
  def update()
    puts loadcon.update({:type => "json", :data => STDIN.read})
  end

  desc "update_attr <obj> <common_name|wc> <key> <value>", "updates a direct (not referenced) attribute of one or more objects."
  option :plain_text, :type => :boolean, :default => false
  def update_attr(obj, cn, k, v)
    if k =~ /(date|last_mod|warranty_start|warranty_end|time_stamp)$/
      v=Time.parse(v).to_i
    end
    if cn =~ /([<>=]| like )/
      obj_arr=loadcon.search(obj,{'fields' => "@id","wc"=>"#{cn} and delete_flag.sym = 'Active'"})
      obj_arr.each do |inner_obj|
        inner_id=inner_obj["@id"]
        template = ERB.new <<-EOF
          {
            "<%= obj %>": {
              "@id": "<%= id %>",
              "<%= k %>": "<%= v %>"
            }
          }
        EOF
        json = template.result_with_hash({
            :obj => obj,
            :id => inner_id,
            :k => k,
            :v => v
          })
        puts loadcon.update({:type => "json", :data => json})
      end
    else
      if options[:plain_text]
        data={
          obj => {
            "@COMMON_NAME" => cn,
            k => v
          }
        }
        json = JSON.pretty_generate(data)
      else
        template = ERB.new <<-EOF
          {
            "<%= obj %>": {
              "@COMMON_NAME": "<%= cn %>",
              "<%= k %>": "<%= v %>"
            }
          }
        EOF
        json = template.result_with_hash({
          :obj => obj,
          :cn => cn,
          :k => k,
          :v => v
        })
      end
      puts loadcon.update({:type => "json", :data => json})
    end
  end

  desc "update_attr_by_id <obj> <id> <key> <value>", "updates a plain attribute of one object by id, does not work"
  def update_attr_by_id(obj, id, k, v)
    template = ERB.new <<-EOF
      {
        "<%= obj %>": {
          "@id": "<%= id %>",
          "<%= k %>": "<%= v %>"
        }
      }
    EOF
    json = template.result_with_hash({
        :obj => obj,
        :id => id,
        :k => k,
        :v => v
      })
    puts loadcon.update({:type => "json", :data => json})
  end

  desc "update_ref_attr <obj> <common_name> <key> <value>", "updates a referenced attribute of one object."
  def update_ref_attr(obj, cn, k, v)
    template = ERB.new <<-EOF
      {
        "<%= obj %>": {
          "@COMMON_NAME": "<%= cn %>",
          "<%= k %>": {
            "@COMMON_NAME": "<%= v %>"
          }
        }
      }
    EOF
    json = template.result_with_hash({
        :obj => obj,
        :cn => cn,
        :k => k,
        :v => v
      })
    puts loadcon.update({:type => "json", :data => json})
  end

  desc "update_ref_attr_by_id <obj> <id> <key> <value_id>", "updates a referenced attribute of one object_id by value-id"
  def update_ref_attr_by_id(obj, id, k, v)
    template = ERB.new <<-EOF
      {
        "<%= obj %>": {
          "@id": "<%= id %>",
          "<%= k %>": {
            "@id": "<%= v %>"
          }
        }
      }
    EOF
    json = template.result_with_hash({
        :obj => obj,
        :id => id,
        :k => k,
        :v => v
      })
    puts loadcon.update({:type => "json", :data => json})
  end


  private

  def loadcon
    if ENV["usduser"] and ENV["usdpass"] and ENV["usdurl"]
      Usd.new(ENV["usduser"],ENV["usdpass"],ENV["usdurl"])
    else
      puts "ACHTUNG:\n\nMindestens einer der Umgebunsvariablen usduser, usdpass und usdurl ist nicht gesetzt. Am besten das Skript #{__dir__}/set_env_prod mit `source` aufrufen!"
      puts "  also :  source  #{__dir__}/set_env_prod \n"
    end
  end

end

Rusdc.start(ARGV)
